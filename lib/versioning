#!/usr/bin/env bash

declare -F version_parse >/dev/null 2>/dev/null || {

    # parse version string
    # @see https://semver.org/
    # @usage: declare -A v && version_parse -n v 1.23.456-pre.release+build.branch && array_print v
    version_parse(){
        declare -a nameref=(); [ "$1" == -n ] && { declare -n result="$2"; read -ra nameref < <( declare -p "$2" 2>/dev/null ); shift 2; } || declare result; declare -r nameref
        result=([version]="$1") && local tmp="$1"
        [[ "$tmp" == *+* ]] && result[build]="${tmp#*+}" && tmp="${tmp%%+*}" # dot-separated build identifiers
        [[ "$tmp" == *-* ]] && result[prerelease]="${tmp#*-}" && tmp="${tmp%%-*}" # dot-separated pre-release identifiers
        result[core]="$tmp" && result[major]="${tmp%%.*}"
        [[ "$tmp" == *.* ]] && tmp="${tmp#*.}" && result[minor]="${tmp%%.*}"
        [[ "$tmp" == *.* ]] && tmp="${tmp#*.}" && result[patch]="${tmp%%.*}"
    }

    # check if version matches rules
    # @usage: version_compatible 2.1.3 '~1.4.0 || ^2.0.0 ' && echo compatible || echo incompatible
    # rules: ~ allow patches, ^ allow minor and patches, * allow anything, >, <, ||
    # todo: ranges e.g. 1.0 - 3.4
    version_compatible(){
        declare -A test; version_parse -n test "$1" && shift && declare rules="${*//[[:space:]]/}" && declare -a t=() && declare -i k=0 i=0 n=${#rules}
        while (( i<n )); do
            if [[ "${rules:k:2}" == @('||'|'>='|'<=') ]]; then ((i+=2))
            elif [[ "${rules:i:1}" == @(^|~|>|<|$'\*') ]]; then ((++i))
            elif [[ "${rules:i:1}" == @([[:digit:]]|[[:alpha:]]|.|+|-) ]]; then
                while [[ "${rules:i:1}" == @([[:digit:]]|[[:alpha:]]|.|+|-) ]]; do ((++i)); done
            else ((++i))
            fi
            t+=("${rules:$k:((i-k))}")
            k=i
        done
        declare -A m=();
        for ((i=0, n=${#t[@]}; i<n; ++i)); do
            if [[ "${t[i]:0:1}" == [[:digit:]] ]]; then
                version_parse -n m "${t[i]}"
                array_print m; echo ---
                [ "${test[core]}" == "${m[core]}" ] && return
            elif [[ "${t[((i+1))]:0:1}" == [[:digit:]] ]]; then
                version_parse -n m "${t[((i+1))]}"
                local -i t0="${test[major]}" t1="${test[minor]}" t2="${test[patch]}"
                local -i m0="${m[major]}" m1="${m[minor]}" m2="${m[patch]}"
                case "${t[i]}" in
                    '>=') [ "${test[core]}" == "${m[core]}" ] && return ;&
                    '>') (( t0 > m0 )) && return; (( t0 == m0 )) && { (( t1 > m1 )) && return; (( t1 == m1 )) && (( t2 > m2 )) && return; };;
                    '<=') [ "${test[core]}" == "${m[core]}" ] && return ;&
                    '<') (( t0 < m0 )) && return; (( t0 == m0 )) && { (( t1 < m1 )) && return; (( t1 == m1 )) && (( t2 < m2 )) && return; };;
                    '~') (( t0 == m0 )) && (( t1 == m1 )) && return ;;
                    '^') (( t0 == m0 )) && return ;;
                    '*') return;;
                    '||') ;;
                esac
            fi
        done
        return 2
    }

}
